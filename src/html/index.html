<!DOCTYPE html>
<html>
<head>
	<title>Datakom - eksamens ark</title>
	<link rel="stylesheet" href="css/exam-paper.css">
	<link rel="stylesheet" href="css/katex.min.css">
	<script src="js/app.js"></script>
</head>
<body>
	<div class="wrapper">
		<section>
			<div class="row">
				<h3>Hva heter de forskjellige lagene i ”Internet Protocol Stack”?</h3>
				<ol class="inline">
					<li>Det fysiske laget</li>
					<li>Datalink laget</li>
					<li>Nettverkslaget</li>
					<li>Transport laget</li>
					<li>Applikasjonslaget</li>
				</ol>


				<h3>Gi en beskrivelse av hva hvert lag sier om arbeidsoppgavene til en protokoll i det laget.</h3>
				<p><strong>Lag 1</strong> kalles det fysiske laget og forteller hva som skal beskrives i det fysiske laget. Det fysiske laget har som oppgave å få overført en bit feilfri mellom to punkter. Det er på dette laget at en beskrivelse av en bit finnes.</p>
				<p><strong>Lag 2</strong> kalles datalink laget og forteller hva som skal beskrives for å få datapakker over til neste node i et nettverk. Protokoller på dette laget har som hovedoppgave å overføre datapakker mellom to punkter/noder. Protokoller på dette laget inneholder beskrivelser av hvordan den delen av en datapakke er bygd opp for å kunne overføre datapakken til neste punkt/node. Lag 2 protokoll inneholder info adressen (f.eks. MAC) til neste punkt/node, slik at riktig node tar imot datapakken. Info om flytkontroll og feilkontroll er også i protokollen for lag 2, slik at en datablokk kan bli feilfri overført mellom to noder/punkt. Protokollen inneholder også info om hvilken protokoll på laget over som skal ha dataene.</p>
				<p><strong>Lag 3</strong> kalles nettverkslaget og forteller hva som skal beskrives for at datapakker skal finne veien gjennom et nettverk. En protokoll på dette laget inneholder info om adressen (f.eks.IP), og kan inneholde info som gjør at alle datapakkene i en overføring blir overført under like forhold, f.eks at pakkene bruker tilnærmet samme tid på å komme seg gjennom nettverket. Protokollen inneholder også info om hvilken protokoll på laget over som skal ha dataene</p>
				<p><strong>Lag 4</strong> kalles transportlaget og forteller hva som skal beskrives for at datapakker skal komme over til endepunktet i forbindelsen. Det kan være et program på endestasjonen (f.eks. PC). En protokoll på dette laget har som hovedoppgave å overføre datablokker mellom to endepunkter, f.eks. fra en applikasjon (program) på en datamaskin til en applikasjon på den andre datamaskinen. En protokoll på transportlaget skal også skjule funksjonene i de underliggende nettverksavhengige lagene fra lagene over.</p>
				<p><strong>Lag 5</strong> kalles applikasjonslaget, og sørger for at data fra applikasjonene på hver side får de data som er nødvendig.</p>


				<p>En protokoll dekker et, eller flere lag i denne modellen (Internet Protokoll Stack).. Grensesnittet mellom lagene er veldefinert. En protokoll kan bruke «tjenester» levert av laget under, og den tilbyr tjenester til laget over. Den samme protokollen kan da brukes på forskjellige protokoller på lagene under. F.eks vil den samme webbrowseren brukes uavhengig av hva slags linje som går ut.</p>
				<h3>Hvorfor er denne lagdelingen laget, som du finner i Internet Protokoll Stack?</h3>


				<h3>Hva er hovedforskjellen mellom OSI referanse modellen og Internet Protokoll Stack. </h3>
				<p>Hovedforskjellen er at i Internet Protokoll Stack mangler lag 5 og 6 (session og presentation), som finnes i OSImodellen. OSI modellen har 7 lag. De grunnleggende protokollene brukt i Internet eksisterte før OSI referanse modellen var laget. Protokollene brukt i Internet hadde i utgangspunktet ikke et så omfattende og klart definerte beskrivelser av arbeidsoppgavene for de forskjellige lagene.</p>
				<p>Etter at OSI modellen kom, startet man også arbeidet med lagdeling av protokollene brukt i Internet. Dette kalles Internet Protocol Stack, eller TCP/IP protocol stack eller TCP/IP modellen. Den inneholder kun 5 lag.</p>


				<h3>Hva er en protokoll, og hva slags type informasjon finner du i en protokoll?</h3>
				<p>En protokoll inneholder info om hvordan en arbeidsoppgave i TCP/IP modellen skal
				løses.</p>
				<p>For at to personer skal kunne snakke sammen, må de bruke samme språk, Da vil de forstå
				hverandre. Når datamaskiner skal overføre data til hverandre, må de bruke samme
				protokoll. Datamaskiner som «snakker sammen», må bruke samme protokoll.</p>
				<p>En protokoll er et sett med regler som beskriver hvordan kommunikasjonen skal foregå.
				En protokoll beskriver oppbyggingen av de forskjellige datapakkene som brukes i
				protokollen. Protokollen beskriver også dataflyten i overføringen, dvs hvilke typer
				datapakker som brukes når, og hvordan de forskjellige sekvensene er, slik som
				oppstartsekvens, dataoverføringssekvens og nedkoblingssekvens.</p>
				<p>En protokoll dekker ett eller flere lag i Internet Protocol Stack. I beskrivelsen av
				protokollen tas det da med bare de detaljene som har med dette eller disse laget å gjøre.
				For eksempel i beskrivelsen av oppbyggingen av datapakker, vil bare de delene, som har
				med de lagene som protokollen dekker, tas med. De andre delene vil ofte bare kalles
				”datadel”.</p>


				<h3>Hva er forskjellene på en bit, en byte og en datapakke?</h3>
				<p>En bit har en, av to mulige tilstander: 0 eller 1.
				En byte består av 8 bit. En byte kan da ha en av 2<sup>8</sup>=256 mulige «verdier», eller forskjellige kombinasjoner av 0 og 1.
				En datapakke består av mange byte som kommer rett etter hverandre. </p>


				<h3>Beskriv en typisk datapakke.</h3>
				<p>En datapakke består av mange byte som kommer rett etter hverandre. I den første delen av
				pakka er hodet (for det laget pakka er i). Hodet inneholder info som er nødvendig for at
				protokollen skal kunne utføre oppgavene den skal gjøre.
				Noen pakker har også en hale, som også er der for at protokollen skal kunne utføre oppgaven
				den skal gjøre</p>
			</div>
			<div class="row">
				<h3>Anta at du har fått tildelt et nett med nett-adresse 158.29.16.00 og maske 255.255.248.0, av din internettleverandør</h3>
				
				<h4>a) Istedet for å angi ditt nett med nett-adresse og maske slik som over, kan det skrives på en annen måte. Hvordan skrives det?</h4>
				<p>255.255.248.0 sier at det er 21 stk 1’ere i masken. I den første byten står det 255, som
				vil si 8 stk 1’ere. Tilsvarende er det i byte nr.2. I byte nr.3 står det 248, som er
				11111000 på binær form. Her er det altså 5 stk 1’ere. Det blir til sammen 8+8+5=21 stk
				1’ere.</p>
				<p>Denne info kan skrives som /21 bak nettadressen: 158.29.16.00 / 21
				Man angir på denne måten: Nettadressen / antall 1’ere i masken. Antall 1’ere i masken,
				angir antall bit i nettdelen av IP adressen. Dette ses på som en del av nettadressen</p>

				<h4>b) Hvor mange host kan du tilknytte ditt nett?</h4>
				<p>Antall host bestemmes av antall 0’ere i masken, som angir antall bit i hostdelen. Her er
				det 32-21=11 stk 0’ere, det vil si 11 bit til host. Det gir: 2<sup>11</sup> – 2 = 2046 host.
				-2 er de to adressene som går bort; nettadressen og broadcastadressen. En host kan ikke
				ha den samme adressen som nettet den er på. En host kan heller ikke ha den samme
				adressen som broadcastadressen, som er den adressen som går til alle.</p>

				<h4>c) Hva blir broadcast-adressen?</h4>
				<p>Broadcast-adressen er den adressen med bare 1’ere i host. Nå går grensen mellom nett
				og host i den 3.byten. Nettadressen er oppgitt til 158.29.16.00/21. Dette skrevet på
				binær form, hvor fet skrift angir nettdelen, og <span class="blue">blå</span> skrift angir hostdelen:
				<code><strong>10011110.00011101.00010</strong><span class="blue">000.00000000</span></code></p>
				<p>Hvis vi setter alle bitene i hostdelen til 1, blir det:</p>
				<p><code><strong>10011110.00011101.00010</strong><span class="blue">111.11111111</span></code> Skrevet på desimal form gir: <code>158.29.23.255</code></p>
				<ul class="inline nostyle">
					<li>Fordi</li>
					<li><code><strong>10011110</strong> = 158</code></li>
					<li><code><strong>00011101</strong> = 29</code></li>
					<li><code><strong>00010</strong><span class="blue">111</span> = 23</code></li>
					<li><code><span class="blue">11111111</span> = 255</code></li>
				</ul>
			</div>
		</section>
		<section>
			<div class="row">
				<h4>d) Hva blir høyeste og laveste IP-adresse på en host på dette nett?</h4>
				<p>Høyeste IP-adresse er en under broadcast-adressen: <code>158.29.23.254</code></p>
				<p>Laveste IP-adresse er en over nettadressen: <code>158.29.16.01</code></p>


				<h3>Nå skal du dele ditt nett opp i to like store subnett.</h3>

				<h4>a) Hva blir nett-adressene på disse to nett?</h4>
				<p>Hvis vi tillater bruk av «subnet zero» og «all 1 subnet», kan vi bruke en bit av
				hostadressen for å lage to nett. De nye subnett-bitene får verdiene henholdsvis 0 og 1.
				De er angitt med <span class="red">rød</span> farge. <strong>Fet</strong> skrift angir nettdelen, og <span class="blue">blå</span> angir hostdelen:</p>
				<p>Vi ser på de to siste bytene:</p>
				<p>Nett 1: <code><strong>00010<span class="red">0</span></strong><span class="blue">00.00000000</span></code> -> 16.00</p>
				<p class="i2">=> Nettadressen for nett 1 blir da: <code>158.29.16.00 / 22</code></p>
				<p>Nett 2: <code><strong>00010<span class="red">1</span></strong><span class="blue">00.00000000</span></code> -> 20.00</p>
				<p class="i2">=> Nettadressen for nett 2 blir da: <code>158.29.20.00 / 22</code></p>

				<h4>b) Hva blir masken på disse to nett?</h4>
				<p>Vi har tatt en bit av hostdelen for å lage disse to subnett. Den nye masken blir da:
				<code>255.255.252.00. (252 = 11111100)</code>, eller skrevet slik: <code>/22</code></p>

				<h4>c) Hva blir broadcast-adressene?</h4>
				<p>Broadcastadressene har bare 1’ere i hostdelen:</p>
				<p>Vi ser på de to siste bytene, og setter 1’er i hostdelen:</p>
				<p>Nett 1: <code><strong>00010<span class="red">0</span></strong><span class="blue">11.11111111</span></code> -> 19.255</p>
				<p class="i2">=> Broadcastadressen for nett 1 blir da:158.29.19.255</p>
				<p>Nett 2: <code><strong>00010<span class="red">1</span></strong><span class="blue">11.11111111</span></code> -> 23.255 </p>
				<p class="i2">=> Broadcastadressen for nett 2 blir da:158.29.23.255</p>

				<h4>d) Hva blir høyeste og laveste IP-adresse på en host på hvert av disse nett?</h4>
				<p>Høyeste IP-adresse er en under broadcastadressen:
				<strong>Nett1:</strong> <code>158.29.19.254</code> <strong>Nett2:</strong> <code>158.29.23.254</code></p>
				<p>Laveste IP-adresse er en over nettnummeret:
				<strong>Nett1:</strong> <code>158.29.16.01</code> <strong>Nett2:</strong> <code>158.29.20.01</code></p>


				<h3>Nå skal du dele ditt nett opp i seks like store subnett.</h3>

				<h4>a) Hva blir nett-adressene på disse nett?</h4>
				<p>For å kunne få 6 subnett må vi bruke 3 bit til subnett. Hvis vi tillater bruk av «subnet zero»
				og «all 1 subnet», ville vi da kunne fått 2<sup>3</sup>= 8 like store subnett. Det er 2 flere subnett enn
				det vi trenger. Hvis vi bare hadde brukt 2 bit til subnett, vill vi bare ha fått 2<sup>2</sup>=4 subnett,
				som er 2 for lite. Derfor må vi bruke 3 bit. </p>
				<p>Hvis det ikke hadde vært tillatt bruk av «subnet zero» og «all 1 subnet», så ville det kunne
				blitt 2<sup>3</sup>-2= 6 subnett. Vi måtte da trekke ifra 2 i antall subnett, fordi da hadde kun nettadressen
				uten maskeinfo, blitt brukt for å indentifisere nette. To nett kan jo ikke ha samme
				nettadresse, eller samme broadcastadresse. De 2 som må trekkes fra er de hvor
				subnettbitene bare er 0’ere, eller bare 1’ere</p>
				<p>For å finne nett-adressene til disse 6 nett, ser vi nærmere på de to siste byte’ene i nettadressen
				til hovednettet. Det er fordi delet mellom nettdel og hostdel går i den 3.byten. Ved
				subnetting vil delet gå i den 4. byten.:</p>
				<p><code>158.29.16.00 / 21</code> <strong>Fet skrift</strong> er bit som er i nettdelen, og <span class="blue">blå</span> er de som er i hostdelen</p>
				<p>Før subnetting: <code><strong>00010</strong><span class="blue">000.00000000</span></code></p>
				<p>Biter med <span class="red">rød skrift</span> er nå brukt til subnetting, og går da over fra å være bit i hostdelen til biter i nettdelen.</p>
				<p>Etter subnetting:</p>
				<ul class="nostyle">
					<li><code><strong>00010<span class="red">000</span></strong>.<span class="blue">00000000</span></code> -> <code>158.29.16.00 / 24</code></li>
					<li><code><strong>00010<span class="red">001</span></strong>.<span class="blue">00000000</span></code> -> <code>158.29.17.00 / 24</code></li>
					<li><code><strong>00010<span class="red">010</span></strong>.<span class="blue">00000000</span></code> -> <code>158.29.18.00 / 24</code></li>
					<li><code><strong>00010<span class="red">011</span></strong>.<span class="blue">00000000</span></code> -> <code>158.29.19.00 / 24</code></li>
					<li><code><strong>00010<span class="red">100</span></strong>.<span class="blue">00000000</span></code> -> <code>158.29.20.00 / 24</code></li>
					<li><code><strong>00010<span class="red">101</span></strong>.<span class="blue">00000000</span></code> -> <code>158.29.21.00 / 24</code></li>
					<li><code><strong>00010<span class="red">110</span></strong>.<span class="blue">00000000</span></code> -> <code>158.29.22.00 / 24</code></li>
					<li><code><strong>00010<span class="red">111</span></strong>.<span class="blue">00000000</span></code> -> <code>158.29.23.00 / 24</code></li>
				</ul>
				<p>De 6 subnett kunne i utgangspunktet få hvilken som helst av disse 8 adresser. Det hadde da
				blitt 2 adresser til overs.
				MEN, det er mer oversiktilig å ta de store nettene i mitten av nummer-området, og bruke
				ytterkanten til mindre nett. Slik sett bruker vi ikke
				<code>158.29.16.00 / 24</code> eller <code>158.29.23.00 / 24</code> til de store subnettene.</p>
				
				<h4>b) Hva blir masken på disse nett?</h4>
				<p>Slik som diskutert fram i forrige oppgave, blir masken <code>/24</code>. Skrevet på den andre måten blir det: <code>255.255.255.00</code></p>
				<div class="clear">
					<div class="fl w4">
						<h4>c) Hvis nettene ikke trengte å være like store, hvordan kunne nettadressene, med maske blitt da?</h4>
						<p>Da kunne vi laget 2 av nettene litt større. Ved å velge de to nettene mitt i nummerområdet, ville det blitt:</p>
					</div>
					<div class="fr w6">
						<ul class="nostyle">
							<li><code><strong>00010<span class="red">000</span></strong>.<span class="blue">00000000</span></code> -> <code>158.29.16.00 / 24</code></li>
							<li><code><strong>00010<span class="red">001</span></strong>.<span class="blue">00000000</span></code> -> <code>158.29.17.00 / 24</code></li>
							<li><code><strong>00010<span class="red">01</span></strong><span class="blue">0.00000000</span></code> -> <code>158.29.18.00 / 23</code></li>
							<li><code><strong>00010<span class="red">10</span></strong><span class="blue">0.00000000</span></code> -> <code>158.29.20.00 / 23</code></li>
							<li><code><strong>00010<span class="red">110</span></strong>.<span class="blue">00000000</span></code> -> <code>158.29.22.00 / 24</code></li>
							<li><code><strong>00010<span class="red">111</span></strong>.<span class="blue">00000000</span></code> -> <code>158.29.23.00 / 24</code></li>
						</ul>
					</div>
				</div>
			</div>
			<div class="row">
				<p><strong>En bedrift har sitt hovedkontor i Halden. Bedriften skal opprette et nytt
				kontor i Fredrikstad. Hovedkontoret i Halden har et lokalnett som er delt i to
				subnett, Ethernet 1 og Ethernet 2, koblet sammen med en ruter (Ruter 1).
				Bedriften er koblet til Internet via den samme ruteren. Kontoret i Fredrikstad
				skal tilknyttes hovedkontoret via en punkt-til-punkt forbindelse. Da dette
				skjer, vil punkt A, på Ruter 1, kobles til punkt B. Se på figuren under.</strong></p>
				<p>La oss først se på kontoret i Halden. IP-nummeret de fikk på sitt nett var
				139.26.154.00/24. Dette har bedriften delt opp i subnett. Adressemasken på
				subnettene (Ethernet 1 og Ethernet 2) er 255.255.255.224. Nettadressen på
				Ethernet 1 er 139.26.154.64. og på Ethernet 2 er 139.26.154.32.</p>
				<div class="clear">
					<img class="fl w4" src="https://i.xdh.no/fae9ae38493a">
					<div class="fr w6">
						<h4>a) Hvor mange PC’er kan tilknyttes Ethernet 1 ? </h4>
						<p>Masken på Ethernet1 er: 255.255.255.224 (siste byte: -> .<strong>111</strong>00000 = .224)
						Det er da 5 bit i hostdelen på nettene. Når 00000 og 11111 ikke kan brukes til en host,
						blir det 2<sup>5</sup>-2=30 host. Et hostnummer går til ruteren. Da blir det 29 PC'er igjen på
						Ethernet1.</p>
					</div>
				</div>
			</div>
		</section>
		<section>
			<div class="row">
				<h4>b) PC1 og PC2 må få hver sin IP-adresse. Hvilke IP-adresser kan de få?</h4>
				<div class="clear">
					<div class="w5 fl sr">
						<p>PC1 ligger på Ethernet1, som har nettnummer 139.26.154.64 / 27,
						64=<strong>010</strong>00000 og masken /27 = 255.255.255.224 -> 224=.<strong>111</strong>00000
						Første nummer: 139.26.154.65, blir ruterens nummer. PC1 kan da få et nummer
						imellom 139.26.154.66 og 139.26.154.94 (66= <strong>010</strong><span class="blue">00010</span>,
						94= <strong>010</strong><span class="blue">11110</span>)</p>
					</div>
					<div class="w5 fr sl">
						<p>PC2 ligger på Ethernet2, som har nettnummer 139.26.154.32 / 27,
						32=<strong>001</strong><span class="blue">00000</span> og masken /27 = 255.255.255.224. -> 224=.<strong>111</strong>00000
						Første nummer: 139.26.154.33, blir ruterens nummer. PC1 kan da få et nummer
						imellom 139.26.154.34 og 139.26.154.62 (34= <strong>001</strong><span class="blue">00010</span>,
						62= <strong>001</strong><span class="blue">11110</span>)</p>
					</div>
				</div>

				<h4>Hva er høyeste og laveste IP-adresse på Ethernet2? – Forklar hvordan du kommer frem til svaret. </h4>
				<div class="clear">
					<div class="w5 fl sr">
						<p>Laveste IP-adresse på Ethernet2 er en over nettadressen: Nettadresse er
						139.26.154.32 (32= <strong>001</strong><span class="blue">00000</span>) Dvs laveste IP-adresse på en host på Ethernet2 blir:
						139.26.154.33 (33= <strong>001</strong><span class="blue">00001</span>)</p>
					</div>
					<div class="w5 fr sl">
						<p>Høyeste IP- adresse på Ethernet2 er en under broadcastadressen, som er :
						139.26.154.63 (63= <strong>001</strong>11111) Dvs høyeste IP-adresse på en host på Ethernet2 blir:
						139.26.154.62 (62= <strong>001</strong>11110)</p>
					</div>
				</div>

				<h4>d) Hva er broadcastadressen til Ethernet1? </h4>
				<p>Ethernet1, har nettnummer 139.26.154.64 /27, 64=<strong>010</strong><span class="blue">00000</span>
				med maske 255.255.255.124. 224=.<strong>111</strong>00000
				Broadcastadressen har bare 1’ere i host-delen av adressen. Masken viser at det er 5 bit i
				hostdelen av adressen. Broadcastadressen blir da:
				139.26.154.95 => <strong>010</strong><span class="blue">11111</span> =95</p>


				<h3>Nå skal kontoret i Fredrikstad tilknyttes kontoret i Halden. Bedriften setter opp en punkt-til—punkt forbindelse mellom de to kontorene. (Punkt A og B knyttes sammen).</h3>

				<h4>a) Hvilke IP-adresser får hvert endepunkt i forbindelsen mellom de to kontorene, og hva blir nettmasken? Ta hensyn til at bedriften ønsker å utnytte IP-numrene best mulig</h4>
				<p>Punkt-til-punkt forbindelsen har bare to tilknytninger, en i hver ende. Vi trenger da et
				nett som bare har mulighet til to tilkoblinger. Antall bit i host-delen er da to.
				Nettnummeret kan tas ifra en av "ytterkantene" av adresseområdet, da de ikke er
				brukt fra før. Det blir altså der hvor det er 0.00 eller 1.11 fra de andre subnettene. Vi
				velger f.eks. 0.00-delen. Det gir</p>
				<ul class="nostyle">
					<li>Nettnummeret: 139.26.154.04 (154.04 = <strong>10011010</strong> . <strong>000 001</strong> <span class="blue">00</span>) </li>
					<li>Nettmasken: /30 = 255.255.255.252 (252 = 11111100)</li>
					<li>IP-nummer for hvert endepunkt: </li>
					<li>139.26.154.05 ( 05 = <strong>000 001</strong> 01) og 139.26.154.06 ( 06 = <strong>000 001</strong> 10)</li>
				</ul>

				<h4>b) Hva blir nettadressen til Ethernet3? </h4>
				<p>Vi kan fritt velge hvilke nettadresser vi gir Ethernet3 av de adressene vi har igjen.
				139.26.154.00/24 er den originale nettadressen, som kan kalles hovednettet. Ethernet 1
				og Ethernet2 er subnett av det hovednettet, hvor det er brukt 3 bit til subnett.
				Hvis <strong>Løsning 1</strong>:
				alle subnett skal være like store, har vi disse valg: </p>
				<ul class="nostyle">
					<li><code>139.26.154.00 / 27</code> (siste to byte: <code><strong>10011010 . <span class="red">000</span></strong><span class="blue">00000</span></code> = 154.00) (subnet zero)</li>
					<li><code>139.26.154.32 / 27</code> (siste to byte: <code><strong>10011010 . <span class="red">001</span></strong><span class="blue">00000</span></code> = 154.32) (Ethernet 2)</li>
					<li><code>139.26.154.64 / 27</code> (siste to byte: <code><strong>10011010 . <span class="red">010</span></strong><span class="blue">00000</span></code> = 154.64) (Ethernet 1)</li>
					<li><code>139.26.154.96 / 27</code> (siste to byte: <code><strong>10011010 . <span class="red">011</span></strong><span class="blue">00000</span></code> = 154.96)</li>
					<li><code>139.26.154.128 / 27</code> (siste to byte: <code><strong>10011010 . <span class="red">100</span></strong><span class="blue">00000</span></code> = 154.128)</li>
					<li><code>139.26.154.160 / 27</code> (siste to byte: <code><strong>10011010 . <span class="red">101</span></strong><span class="blue">00000</span></code> = 154.160)</li>
					<li><code>139.26.154.192 / 27</code> (siste to byte: <code><strong>10011010 . <span class="red">110</span></strong><span class="blue">00000</span></code> = 154.192)</li>
					<li><code>139.26.154.224 / 27</code> (siste to byte: <code><strong>10011010 . <span class="red">111</span></strong><span class="blue">00000</span></code> = 154.224) (all 1 subnet)</li>
					<li>Ethernet1 har fått nettnummer: 139.26.154.64 / 27</li>
					<li>Ethernet2 har fått nettnummer: 139.26.154.32 / 27</li>
				</ul>
				<p>Her kan vi velge en av 6 nettadresser til Ethernet 3.
				<code>139.26.154.00 / 27</code>, eller <code>139.26.154.96 / 27</code> eller <code>139.26.154.128 / 27</code> ...
				<code>139.26.154.224 / 27</code></p>
				<p>Med denne løsningen vil firmaet meget enkelt kunne utvide med flere kontorer, og alle
				kontorer får samme størrelse på sitt nett. Hvis firmaet ikke ser for seg flere kontorer,
				og ønsker å bruke mest mulig av de tildelte IP-numrene, kan man vurdere et større nett
				for kontoret i Fredrikstad:</p>
				<p><strong>Løsning 2:</strong></p>
				<ul class="nostyle">
					<li><code>139.26.154.128 / 25</code> (Masken er da <code>255.255.255.128</code>, som er et større nett)</li>
					<li><code>139.26.154.128 / 25</code> (siste to byte: <code><strong>10011010 . <span class="red">1</span></strong><span class="blue">0000000</span></code> = 154.128)</li>
				</ul>

				<h4>c) Hva blir nettmasken til de Ethernet3?</h4>
				<p>Som angitt i oppgaven over:
				<strong>Løsning 1</strong> gir:
				Nettmasken til Ethernet3 er den samme som på Ethernet1 og Ethernet2:
				255.255.255.224. (224=.<strong>111</strong>00000)</p>
				<p><strong>Løsning 2</strong> gir <code>255.255.255.128</code> (128=.<strong>1</strong>0000000)</p>

				<h3>Hva er DHCP, og hvordan virker den?</h3>
				<p>Hvis du har et stort nettverk vil det ta enormt mye tid å skrive inn IP adressen på hver host som er
				på nettverket. Heldigvis kan man bruke DHCP i stedet. En maskin på nettverket kan settes opp som en DHCP
				server. En DHCP server gir hver host på nettverket, som spør om det, IP adresse, subnett maske og default
				gateway adresse.</p>
				<p>DHCP står for Dynamic Host Configuration Protocol, og den brukes for å dele ut IPadresse til en maskin som forespør om en IP-adresse.</p>
				<p>Det finnes en DHCP server som dekker et eller flere subnett. Denne har et sett med IPadresser som den kan dele ut fra, til maskiner som forespør om en IP-adresse. </p>
				<p>Et eksempel på DHCP:</p>
				<p class="i1">
					En maskin som blir slått på, og som er satt til å forespørre en DHCP-server om sin
					IP-adresse, sender en DHCP DISCOVER pakke til DHCP-serveren. Når denne
					kommer fram til DHCP-serveren, retunerer den IP-adresse i en DHCP-OFFER
					pakke. Hvis maskinen som mottar denne, godtar dette nummer, sender den en
					DHCPREQUEST pakke tilbake til DHCP serveren. DHCP-serveren sender tilbake
					en DHCPACK pakke. Samtidig settes en timer i gang. Enhver maskin må
					”oppdatere” sin IP-adresse jevnlig, ved å sende en melding til DHCP-serveren. Hvis
					DHCP-serveren ikke mottar en slik oppdatering innen timeren er gått ut, vil den
					frigjøre IP-adressen, som da kan deles ut til en annen maskin som forespør om en
					IP-adresse. 
				</p>
				<p>DHCP bruker UDP (User Datagram Protocol) protokollen. DHCP serveren bruker port nummer 68.DHCP klienten bruker port nummer 67.</p>
			</div>
			<div class="row bl bt">
			</div>
		</section>
	</div>
	<div class="wrapper">
		<section>
			<div class="row">
				<h3>Hvordan er en MAC adresse bygd opp?</h3>
				<p>MAC adressen kalles også ”den fysiske adressen” eller ”hardware adressen”. Det er
				MAC adressen som en PC bruker for å bestemme om en datapakke skal tas imot.
				MAC adressen består av 48 bit, dvs 6 byte. De 3 første byte sier hvilken produsent av
				nettkortet det er. De 3 siste byte bestemmer produsenten selv. Det finnes ikke to
				nettkort som har den samme fysiske adressen.</p>
				<div class="clear">
					<div class="w5 fl">
						<p>Det finnes flere typer MAC adresser. </p>
						<ol>
							<li>
								<p>Den individuelle, som er individuell for alle nettverkskort. Det finnes ingen
								nettverkskort som har samme MAC adresse. De første 24 bit bestemmer
								hvilken produsent det er. De neste 24 bit bestemmer produsenten selv. Denne
								type MAC adresse kalles også unicast (kun for dette nettkort) og er «globally
								unique»</p>
							</li>
							<li>
								<p>En annen type MAC adresse kan programmeres på kortet. Den er «locally administered». </p>
							</li>
							<li>
								<p>Det finnes også en multicast MAC adresse, som også kan programmeres. Det
								er en MAC adresse som brukes når mange host i et nett skal ta imot
								datapakken</p>
							</li>
						</ol>
						<p>Det er to bit i første byte som bestemmer hvilken type MAC adressen det er. En bit
						indikerer om det er en «globally unique» adresse eller «locally administrert» adresse.
						En annen bit indikerer om det er en unicast adresse </p>
					</div>
					<img src="https://i.xdh.no/4b94e016cf6a" class="w5 fr">
				</div>


				<h3>Hva er forskjellene på en MAC adresse og IPv4 adresse? </h3>
				<p>En MAC adresse virker på lag 2 i TCP/IP modellen. Det er ikke mulig å finne ut hvor en host
				med en bestem MAC adresse befinner seg på internet, før datapakken er på dette samme
				lokalnettet hvor denne MAC adressen befinner seg.</p>
				<p>En IPv4 adresse virker på lag 3 i TCP/IP modellen. Det er et system på disse
				adressene slik at det er mulig å finne ut hvor en IPv4 adressen befinner seg på
				internet.</p>
				<p>En MAC adresse består av 6 byte, slik som forklart i oppgave nr.1. En IPv4
				adresse består av totalt 4 byte. Adressen består av en nettdel og en hostdel. En host
				vil få en ny IPv4 adresse når den blir koblet til et annet nett (LAN). Alle host på et
				LAN har samme nettdel av adressen.</p>


				<h3>Forklar alle delene i et IPv4 hode.</h3>
				<div class="clear">
					<img class="w7 fl" src="https://i.xdh.no/727c8453b3a6">
					<div class="w3 fr">
						<ul class="nostyle">
							<li>
								<strong>Verson</strong>
								<p>De 4 første bit er versjon nummer på IP. Her er det tallet 4.</p>
							</li>
							<li>
								<strong>TOS</strong>
								<p>Type of service. Vanligvis ikke i bruk, men kan brukes til angi spesielle tjenester IP pakka skal ha, eller krav pakka setter til nettverket.</p>
							</li>

							<li>
								<strong>Source address</strong>
								<p>En 4 byte lang adresse som sier fra hvilken IP adresse denne pakken kommer fra.</p>
							</li>
							<li>
								<strong>Destination address</strong>
								<p>En 4 byte lang adresse som sier hvilken IP adresse denne pakken skal til.</p>
							</li>
						</ul>
					</div>
				</div>
				<ul class="nostyle i0">
					<li>
						<strong>IHL</strong>
						<p>De neste 4 bit er IHL (IP Header Length). Det er antall 32 bit «deler» i hodet.
						Vanligvis er dette tallet 5, da en normal IPv4 hode består av 5 stk 32 bit «deler»,
						totalt 5*32 bit = 160 bit, eller 20 byte.</p>
					</li>
					<li>
						<strong>Total length</strong>
						<p>Dette er et tall som angir totalt antall byte i denne IP pakka, både hode og data.
						Identification: Et nummer som spesifikt identifiserer denne IP pakka. Brukes sammen med
						Fragmentering.</p>
					</li>
					<li>
						<strong>Flags</strong>
						<p>3 bit som har med fragmentering å gjøre. To av bitene brukes. En bit (M) sier at det
						er flere fragmenter eller ikke. En bit (D) sier om det er lov å fragmentere eller ikke.</p>
					</li>
					<li>
						<strong>Fragment offset</strong>
						<p>Når en større pakke er fragmentert (delt opp i flere deler), forteller dette
						feltet hvor datadelen i denne IP pakka skal være. Det første fragmentet har offset 0.
						Neste fragment sier hvor langt ut i den originale ufragmenterte pakka, denne
						datadelen hører til</p>
					</li>
					<li>
						<strong>Time to live</strong>
						<p>Time To Live. Et 8 bit tall som minker med en for hver router. Hvis pakken har gått
						igjennom så mange routere at den blir 0, vil pakken stoppe. Den routeren som
						stoppet pakken, vil gi beskjed tilbake til senderen om at pakken ble stoppet.</p>
					</li>
					<li>
						<strong>Protocol</strong>
						<p>Et nummer som angir hvilken protokoll på transportlaget, som skal ha denne pakka.
						For eksempel TCP har verdien 6, UDP har verdien 17.</p>
					</li>
					<li>
						<strong>Header checksum</strong>
						<p>Dette er et tall som er beregnet på bakgrunn av verdiene i bytene i hodet.
						Dette brukes for å finne ut om det er blitt bitfeil i hodet</p>
					</li>
				</ul>
			</div>
			<div class="row bt br">
				
			</div>
		</section>
		<section>
			<div class="row">
				<h3>Forklar alle delene i et IPv6 hode.</h3>
				<div class="clear">
					<div class="w5 fl">
						<ul class="nostyle i0">
							<li>
								<strong>Traffic class</strong>
								<p>8 bit, som tilsvarer TOS i IPv4 hodet</p>
							</li>
							<li>
								<strong>Flow label</strong>
								<p>20 bit som identifiserer at en pakke tilhører en bestem «flow» av data. Alle som
								er i samme «flow» krever samme «behandling» i nettet. Eksempel på pakker som
								er en del av en flow, kan være audio eller video pakker</p>
							</li>
							<li>
								<strong>Payload length</strong>
								<p>Antall byte i datadelen av IPv6 pakka</p>
							</li>
						</ul>
					</div>
					<img class="w5 fr" src="https://i.xdh.no/281499706ff9">
					<ul class="nostyle i0">
						<li>
							<strong>Next header</strong>
							<p>Sier hva som er i neste hodet. IPv6 kan ha flere forskjellige tilleggshoder, som
							kan oppfylle spesielle funksjoner. Hvis det ikke er et tillegshodet, vil next header
							innholde info om hodet på transportlaget, f.eks om det er et TCP hode eller UDP
							hode.</p>
						</li>
						<li>
							<strong>Hop limit</strong>
							<p>Tilsvarende som TTL i IPv4. Dette er et tall som minker med en for hvert hopp
							(hver router). Hvis den kommer til 0, vil routeren stoppe pakka, og sende info
							tilbake til sender med info om at pakka er stoppet</p>
						</li>
					</ul>
				</div>


				<h3>Hva er hovedforskjellene mellom IPv4 og IPv6?</h3>
				<p>Det er flere hovedforskjeller</p>
				<ol>
					<li>
						<p>Adressefeltet er mye større i IPv6. Det er det 128 bit, mens i IPv4 er det 32 bit. Det er
						også flere adressetyper i IPv6. I tillegg til unicast adresse (en enkelt enhet), slik som også
						IPv4 har, har IPv6 anycast og multicast adresse. Anycast tas imot av den første, den
						nærmeste, av et sett host’s som utgjør anycast adressen. En multicast adresse blir sendt til
						alle som er en del av multicast adressen. Det kan sammenlignes med broadcast adressen i
						IPv4. </p>
					</li>
					<li>
						<p>IPv6 hodet har sløyfet en del felt, som gjør at prosesseringen på info i IPv6 hodet går
						raskere. Header Checksum er fjernet, som gjør at lag3-utstyr slipper å foreta beregningen
						på header checksum. IPv6 har sløyfet info om lengden på hodet, og muligheten av
						”option” i hodet. I stedet legger IPv6 opp til å bruke flere etterfølgende hoder. Denne
						metode gjør prosesseringen på et standardhode raskere.</p>
					</li>
				</ol>


				<h3>Hvordan kan en IPv6 pakke bli sendt i et IPv4 nett?</h3>
				<p>Hvis det er et gammelt IPv4 nett, hvor routerne ikke har mulighet for å håndtere både IPv6
				og IPv4, kan det brukes ”tunneling” for å sende en IPv6 pakke igjennom et IPv4 nettverk.
				Hele IPv6 pakka pakkes inn i datadelen av IPv4 pakka.
				Hvis det brukes routere som både kan ta IPv4 og IPv6, kan det brukes «dual-stack». Da blir
				IPv6 pakka sent igjennom nettet som en IPv6 pakke.</p>

				<h3>På internet er det noe som heter AS. Hva er et AS, og hvorfor har vi det?</h3>
				<p>Autonomous System (AS) er en del av internet, som består av flere routere. Internet er delt
				opp i mange AS. Hver av disse AS indentifiseres med et nummer; AS &lt;nr&gt;. Routerne innen et
				AS utveksler info, bla. routinginfo seg i mellom via bestemte protokoller. En stor bedrift,
				eller institusjon, kan ha sitt eget AS &lt;nr&gt;.</p>
				<p>Internet er delt inn i flere AS bla. fordi det er for mange routere i hele internet, til at alle kan
				utveksle info seg i mellom. Det er derfor hensiktsmessig å la et begrenset antall routere, som
				i et AS, utveksle info seg i mellom. Routerne som er ”i kanten” på et slik AS, kalles en
				gateway router. Gateway routere kommuniserer med en tilsvarende gateway router i et annet
				AS. Den vanlige routing protokollen mellom AS er BGP. </p>
				<p>Et AS kan i prinsippet velge hvilken routing algoritme, og dermed routing protokoll som skal
				brukes i sitt AS. Vanlige routing protokoller innen et AS er RIP eller OSPF.</p>
			</div>
			<div class="row">
				<h3>Hva er hovedoppgaven til en rutings algoritme, og hva heter de to (mest kjente)
				prinsippene for rutings algoritmer, og hva er forskjellene på de? Gi en kort
				forklaring på de to.</h3>
				<p>En ruting algoritme’s (eng: routing algorithm) hovedoppgave er å finne den beste veien
				mellom to host i nettverket. Den ”beste” veien kan også kalles den ”billigste” veien, eller
				veien med ”minst kostnad” (least cost). Det er flere faktorer som avgjør en ”kostnad”, ikke
				bare penger.</p>
				<p>Det er to hovedprinsipper for rutings algoritmer: </p>
				<ol class="nostyle i0">
					<li>
						<strong>En global rutings algoritme:</strong>
						<p>Her vet rutings algoritmen alle kostnader på alle forbindelser i nettet, før den starter
						på beregningen. En slik algoritme kalles også en Link-State (LS) algoritme. En mye
						brukt LS algoritme er Dijkstra’s algoritme. – En slik algoritme må altså innhente alle
						kostnader i nettet, på forhånd. Blir det forandring på kostnaden på en forbindelse, må
						info om hele nettet ut på nytt til alle som skal foreta denne algoritmen. </p>
					</li>
					<li>
						<strong>En desentralisert rutings algoritme:</strong>
						<p>Her vet rutings algoritmen kun kostnadene på sine egne forbindelser, når den starter.
						En slik algoritme kalles også en Distance-Vector (DV) algoritme. Info sendes
						etterhvert ut til de nærliggende routerne, som bruker denne info for den videre
						beregning. Slik sprer routings info seg gradvis utover i nettverket, helt til alle har fått
						all info som er nødvendig for å vite kostnadene i hele nettet.</p>
					</li>
				</ol>


				<h3>Nevn de tre mest vanlige rutingsprotokollene.</h3>
				<ul class="nostyle i0">
					<li>
						<p>Routing Information Protocol (RIP) bruker en DVrutings algoritme, og er mest utbredt, da
						den brukes i de nederste lag i internet hierakiet. Her er det flest routere</p>
					</li>
					<li>
						<p>Open Shortest Path First (OSPF) bruker en LS rutings algoritme. De brukes oftest i routere i
						”backbone” nettverk, som forbinder forskjellige områder innen internet (ikke AS, men
						mindre hoveddeler)</p>
					</li>
					<li>
						<p>Border Gateway Protocol (BGP) er den mest komplekse, og brukes mellom AS. </p>
					</li>
				</ul>


				<h3>Hva er forskjellene på intra-AS rutings protokoll og inter-AS rutings protokoll?</h3>
				<p>Intra-AS routing protokoll er routing protokoll som brukes innen et AS. Routings
				protokollene RIP eller OSPF er vanlige intra-AS routings protokoller.</p>
				<p>Inter-AS routing protokoll er routing protokoll som brukes mellom forskjellige AS. Routing
				protokollen BGP er en vanlig inter-AS routing protokoll.</p>
			</div>
			<div class="row bt br bl">
				
			</div>
		</section>
		<section>
			<div class="row">
				<h3>Forklar litt om hvordan kryptering foregår og nøkler. Nevn også eksempler på
				typer av nøkler og hvordan de brukes i en "sikker" datakommunikasjon.</h3>
				<p>Kryptering foregår ved at ved sendersiden sendes «klartekst» inn i en krypterings algoritme,
				som bruker info fra en «nøkkel» til å lage den krypterte datastrømmen (ciphertext)</p>
				<img src="https://i.xdh.no/ad469c91008e">
				<p class="tc w10">Public key cryptography</p>
				<p>Denne krypterte datastrømmen er umulig å dekode tilbake til klartekst uten bruk av riktig
				nøkkel og dekodings algoritme.</p>
				<p>Det brukes to nøkler, en offentlig nøkkel og en privat nøkkel. Den offentlige brukes til
				krypteringen og den private brukes til å dekryptere. Den offentlige nøkkelen kan være kjent
				av alle, men den private nøkkelen må være hemmelig. Disse to nøklene hører sammen.</p>


				<h3>Hva menes med "effektivitet" på en dataoverføring?</h3>
				<p>Effektiviteten er gitt av forholdet mellom tiden som brukes til å sende data, og tiden til neste
				pakke (eller serie med pakker) kan sendes. Hvis vi setter tiden for å sende en pakke til t<sub>trans</sub> og
				tiden signalet bruker for å komme fra sender (S) til mottager (M) og tilbake igjen; RTT.
				RTT=Round Trip Time. L=pakkestørrelsen og R=bithastigheten, blir U ved stopp-og-vent
				overføring (idle RQ):</p>
				<div class="katex">
					U = \dfrac{t_{trans}}{RTT+t_{trans}}
					  = \dfrac{^L/_R}{RTT+^L/_R}
				</div>
				<p>Ved kontinuerlig dataoverføring, med et sendevindu på K, må uttrykket multipliseres med K.
				Effektiviteten U kan ikke være større enn 1,0, så hvis multiplikasjonen med K gir en U større
				enn 1,0, blir U=1,0</p>

				<p>Hva er effektiviteten på en forbindelse til universitetet i Sofia? Anta at du har en
				kontinuerlig overføring, med et sendevindu på 16 pakker. Pakkestørrelsen er på
				1024 byte, og datahastigheten ut av din PC er 50 Mbit/s. Forsinkelsen til
				universitetet i Sofia kan du lese ut av en ping til maskinen:</p>
				<ul class="nostyle io">
					<li><code>Pinging www.uni-sofia.bg [62.44.96.22] with 32 bytes of data:</code></li>
					<li><code>Reply from 62.44.96.22: bytes=32 time=52ms TTL=51</code></li>
					<li><code>Reply from 62.44.96.22: bytes=32 time=52ms TTL=51</code></li>
					<li><code>Reply from 62.44.96.22: bytes=32 time=52ms TTL=51</code></li>
					<li><code>Reply from 62.44.96.22: bytes=32 time=52ms TTL=51</code></li>
					<li><code>Ping statistics for 62.44.96.22:</code></li>
					<li><code>Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),</code></li>
					<li><code>Approximate round trip times in milli-seconds:</code></li>
					<li><code>Minimum = 52ms, Maximum = 52ms, Average = 52ms </code></li>
				</ul>
				<p>Vi setter inn i formelen:</p>
				<div class="katex">
					U = K \cdot \dfrac{ L/R }{ RTT+L/R }
					  = 16 \cdot \dfrac{ ^{(1024 \cdot 8)}/_{(50 \cdot 10^6)} }{ ^{(52 \cdot 10^{-3})+(1024 \cdot 8)}/_{(50 \cdot 10^6)} }
					  = \dfrac{ 2,6 }{ 52 }
					  = \underline{\underline{0,05}}
				</div>


				<h3>Hva blir den effektive datahastigheten på forbindelsen til universitetet i Sofia?
				Gi svaret i bit/s (evt kbit/s eller Mbit/s).</h3>
				<p>Den effektive datahastigheten er effektiviteten multiplisert med (den fysiske)
				datahastigheten. Det bli:</p>
				<p>Datahastigheten blir Uˑ50 Mbit/s = 0,05ˑ50 Mbit/s = <span class="katex">\underline{\underline{2,5 Mbit/s}}</span></p>
			</div>
			<div class="row">
				<p>Du skal finne ut hvor mye en BER (Bit Error Rate) påvirker effektiviteten.
				Pakkestørrelsen er på 2048 byte og datahastigheten er på 100 Mbit/s (100·106
				bit/s)</p>
				<p>Forsinkelsen til NTNU kan du lese ut av en ping:</p>
				<ul class="nostyle i0">
					<li><code>Pinging lvs56vip12.it.ntnu.no [129.241.56.202] with 32 bytes of data:</code></li>
					<li><code>Reply from 129.241.56.202: bytes=32 time=9ms TTL=56</code></li>
					<li><code>Reply from 129.241.56.202: bytes=32 time=9ms TTL=56</code></li>
					<li><code>Reply from 129.241.56.202: bytes=32 time=10ms TTL=56</code></li>
					<li><code>Reply from 129.241.56.202: bytes=32 time=9ms TTL=56</code></li>
					<li><code>Ping statistics for 129.241.56.202:</code></li>
					<li><code>Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),</code></li>
					<li><code>Approximate round trip times in milli-seconds:</code></li>
					<li><code>Minimum = 9ms, Maximum = 10ms, Average = 9ms </code></li>
				</ul>

				<h4>a) Regn ut effektiviteten til NTNU med bruk av idle-RQ protokoll, og feilfri
				overføring. (BER=0)</h4>

				<p>Vi setter inn i formelen:</p>
				<div class="katex">
					U = K \cdot \dfrac{ L/R }{ RTT+L/R }
					  = 16 \cdot \dfrac{ ^{(2048 \cdot 8)}/_{(100 \cdot 10^6)} }{ ^{(9 \cdot 10^{-3})+(2048 \cdot 8)}/_{(100 \cdot 10^6)} }
					  = \dfrac{ 164 \cdot 10^{-6} }{ 9 \cdot 10^{-3} }
					  = \underline{\underline{0,018}}
				</div>
			</div>
			<div class="row bt bl">
				
			</div>
		</section>
	</div>
	<div class="wrapper">
		<section>
			<div class="row">
				<h4>Regn ut effektiviteten til NTNU med bruk av idle-RQ protokoll, hvor BER=2ˑ10<sup>-5</sup></h4>
				<p>Vi må første regne ut sannsynligheten for feil i en pakke, P<sub>f</sub>: </p>
				<p><span class="katex">P_f = BER \cdot (antall\ bit\ i\ pakke) = BER \cdot L = 2 \cdot 10^{-5} \cdot (2048 \cdot 8) = 0,328</span></p>
				<p>Dette brukes i den nye formelen for effektiviteten U, hvor P<sub>f</sub> inngår:</p>
				<div class="katex">
					U = \dfrac{ 1-P_f }{ 1+RTT/\frac{L}{R} }
					  = \dfrac{ 1-0,328 }{ \dfrac{ 1+(9 \cdot 10^{-3}) }{ (2048 \cdot 8)/(100 \cdot 10^6) } }
					  = \dfrac{ 0,672 }{ 56 } = 0,012
				</div>


				<h3>Hvordan virker flytkontrollen mellom to host på transportlaget? Anta at det
				brukes TCP protokollen.</h3>
				<p>Flytkontroll er en metode for å kontrollere og styre flyten av data mellom sender
				og mottager. Uten denne flytkontrollen ville mottageren kunne kommet i den
				situasjonen at den ikke klarte å ta unna all data som kom fra senderen. Senderen
				kunne da ha sent data for fort for mottageren, og data kunne blitt tapt.</p>
				<p>Mottageren har et mottagerbuffer, der data legger seg før de sendes opp til applikasjonen.
				Det bufferet må være der fordi vi kan ikke anta at applikasjonen er klar til ta imot data da
				data faktisk kommer. Applikasjonen kan være opptatt med andre oppgaver da data kommer. Så
				lenge dette mottagerbufferet har plass nok, kan sender bare sende data til mottager.</p>
				<p>Flytkontroll oppnås ved at mottageren sender info om hvor mye ledig plass den
				har i mottagerbufferet, tilbake til senderen. Denne info legger seg i TCP hodet, i
				”Receive window”, og sendes tilbake i en ACK pakke. Det kan også legges i en
				datapakke som sendes fra mottager til sender, altså hvis det sendes data begge
				veier samtidig.</p>


				<h3>Hvordan løser TCP køkontroll? Hvordan virker køkontroll i TCP?</h3>
				<p>Køkontroll er en metode for styre kø. Kø kan oppstå i et nettverk ved at flere
				forbindelser går igjennom en nettverksenhet, f.eks en ruter. Summen av
				trafikken for hver forbindelse kan bli for stor for den ruteren, og da vil pakker bli
				tapt. TCP må ha mekanismer som vil kunne justere trafikken på sin forbindelse,
				slik at alle pakker slipper igjennom.</p>
				<p>Nå har ikke nettverksenhetene i ”vanlig” Internet, f.eks ruterne, mulighet til å gi
				beskjed om kø hos seg. Hadde den hatt den muligheten, kunne den ha gitt
				beskjed om køtilstanden tilbake til TCP forbindelsene. TCP må bruke andre
				midler for å finne ut av køtilstanden, og justere trafikken i henhold til den</p>
				<p>TCP starter forsiktig ved å bruke ”slow-start”. Den begynner ved å sende kun en
				pakke. Neste pakke sendes først etter at ACK har kommet. Da vil den øke
				vindustørrelsen til 2. For hver ACK legger den på en pakke i vinduet. Det vil
				medføre at vindusstørrelsen dobbles for hver gang (hver RTT). Slik fortsetter
				den inntil den oppdager at pakker blir borte (ved at timeout slår til). Da justerer
				den vindusstørrelsen tilbake til 1 pakke. (En pakke er MSS stor). Samtidig har
				den notert hva vindusstørrelsen var da timeout slo til. ”Threshold” settes til
				halvparten av den verdien.</p>
				<p>Nå vil den kjøre slow-start igjen, men den vil doble vindusstørrelsen kun inntil den har kommet til
				”Threshold”. Det var jo den vindusstørrelsen hvor det gikk bra forrige gang. Ved neste dobling ble det
				jo pakketap.</p>
				<p>Når vindusstørrelsen har nådd ”Threshold” verdien, går den inn i ”congestion avoidance” tilstand,
				hvor økning av vindusstørrelsen skjer mye mer forsiktig. I stedet for dobling, øker den med kun 1 for
				hver RTT. Slik øker den inntil det blir tap av pakker igjen.</p>
				<p>Tap av pakker oppdages enten ved at timeout slår til, eller at det har kommet 3 duplikate ACK. Dvs at
				2 like ACK har kommet 3 ganger. En duplikat ACK betyr at pakken kom riktig fram på andre forsøk. Køen er
				da ikke så stor.Hvis timeout slår til, betyr det at ingen pakker har kommet fram. Da er køen stor.</p>
				<p>Hvis tap oppdages ved at 3 duplikate ACK har kommer, går den inn i ”Fast recovery” tilstand. Det vil
				si at vindusstørrelsen går tilbake til halvparten av hva den var da tap skjedde, og den går inn i
				”congestion avoidance” tilstand. Dvs. pakkestørrelsen øker kun med 1 for hver RTT. Denne økningen fortsetter
				inntil det blir tap igjen.</p>
				<p>Hvis tap oppdages ved at timeout slår til, går vindusstørrelsen tilbake til slow start tilstand.
				Vindusstørrelsen går da tilbake til 1.</p>
				<p>For hver gang det blir duplikat ACK (to like ACK etter hverandre), øker duplikat ACK telleren.</p>


				<h3>Hva er forskjellene mellom UDP og TCP? </h3>
				<p>UDP står for User Datagram Protocol og er en ”connectionless” protokoll. Det vil si at
				forbindelsen ikke blir satt opp først. Det er data i første pakke. UDP er en usikker protokoll
				da den ikke gir noen respons tilbake om pakka har kommet fram, og veien som den tar kan
				være forskjellig for hver pakke som går. UDP inneholder lite ”overhead”, og det går da
				raskere å sende data med UDP enn TCP. </p>
				<p>TCP står for Transmission Control Protocol og er en ”connected oriented” protokoll. Det vil
				si at forbindelsen blir satt opp før data sendes. Alle pakkene som sendes i en melding følger
				samme veien. Pakkene kommer også fram i riktig rekkefølge og det er mulighet for
				retransmisjon ved feil. TCP-hodet inneholder nok info til å styre alt dette. Det blir da
				forholdsvis mye ”overhead”, som gjør at det går tregere med TCP enn UDP. </p>
				<p>TCP er egnet der hvor det er viktig at alle pakker kommer riktig fram, selv om det ikke går så
				hurtig. F.eks. hvis en webside blir overført, eller i en forbindelse med banken. UDP er egnet
				der hvor det ikke er så kritisk hvis en pakke skulle bli borte, men det er viktig at forbindelsen
				er rask. F.eks. der hvor lyd og/eller film blir overført. </p>

				<div class="clear">
					<div class="fl w5">
						<h3>Hva slags info finnes i hodet på en UDP pakke?</h3>
						<p>Et UDP hode inneholder kun fra og til- portnummer, lengden på datapakka og sjekksummen for datapakka</p>


						<h3>Hva slags info finnes i hodet på en TCP pakke?</h3>
						<img class="w8" src="https://i.xdh.no/012d5c1ec980" alt="TCP">
					</div>
					<div class="fr w5">
						<img class="w5" src="https://i.xdh.no/fe2320f9d6ad" alt="UDP">
						<p>Et TCP hode inneholder fra- og tilportnummer. Til-portnummeret er nummeret til den socket som
						applikasjonen skal ha data inn på. Fra-portnummeret er nummeret til den socket som applikasjonen
						forventer et svar på.</p>

						<ul class="nostyle i0">
							<li>
								<strong>Sequence number</strong>
								<p>Nummeret på pakka. Dette nummer øker for hver pakke, slik at mottageren kan finne ut av rekkefølgen på pakkene. (Egentlig er det bytenummer, slik at tallet øker ikke med en, men med hvor mange byte det var i pakka)</p>
							</li>
						</ul>
					</div>
				</div>
			</div>
		</section>
		<section>
			<div class="row">
				<div class="clear">
					<ul class="nostyle i0 w5 fl sr">
						<li>
							<strong>Acknowldgement number</strong>
							<p> nummeret på pakka som kom fra den andre siden. Dette blir
							en OK melding (ACK) på data som kom fra den andre siden.
							(Bytenummer her også)</p>
						</li>
						<li>
							<strong>Header length</strong>
							<p>forteller hvor mange 32 bits ord som er i hodet. Denne info brukes for å finne
							ut om det sendes options i hodet, og da hvor stort det er.</p>
						</li>
						<li>
							<strong>Kontroll bits</strong>
							<p>URG: Urgent Pointer: Hvis denne bit er satt, er det data i Urgent data pointer</p>
						</li>
						<li>
							<strong>ACK</strong>
							<p>Hvis denne bit er satt, er acknowledgement number gyldig.</p>
						</li>
						<li>
							<strong>PSH</strong>
							<p>Push Function: Hvis denne bit er satt må mottageren levere dataene til
							applikasjonen så raskt som mulig.</p>
						</li>
					</ul>
					<ul class="nostyle i0 w5 fr sl">
						<li>
							<strong>RST</strong>
							<p>Reset the Connection: Hvis denne bit er satt, betyr det at sender avbryter sendingen
							og all data mottatt i denne TCP forbindelsen kan slettes.</p>
						</li>
						<li>
							<strong>SYN</strong>
							<p>Synchronize: Hvis denne bit er satt betyr det at sender forsøker å synkronisere
							sekvens nummer. Dette signal kommer gjerne under initiering av en sending.</p>
						</li>
						<li>
							<strong>FIN</strong>
							<p>Det betyr at det ikke er noe mer data i denne TCP forbindelsen hos sender.</p>
						</li>
						<li>
							<strong>Receive windows</strong>
							<p>brukes som flyt kontroll. Her forteller mottageren hvor mange byte den har
							plass til i mottagerbufferet sitt.</p>
						</li>
						<li>
							<strong>Internet checksum</strong>
							<p>brukes for å finne ut om det er bitfeil i pakka</p>
						</li>
						<li>
							<strong>Urgent pointer</strong>
							<p>En peker til data som mottageren må bearbeide så snart som mulig</p>
						</li>
					</ul>
				</div>
			</div>
			<div class="row">
				<h3>Hva er DNS? Forklar litt om virkemåten.</h3>
				<p>Hovedhensikten med DNS er å oversette et hostnavn til en IP adresse og vise versa. Den motsatte veien, å oversette en IP adresse til et domain navn, kalles "Reverse DNS".</p>
				<img class="w5 fl" src="https://i.xdh.no/4b41b98ff468">
				<img class="w5 fr" src="https://i.xdh.no/ab0bc54c7a25">
				<hr>
				<div class="w5 fl sr">
					<p>Datamaskinene må bruke IP adresse for å finne fram til en annen maskin, for
					eksempel en web-server eller mail-server. For oss mennesker er det mer naturlig å bruke et navn enn et
					nummer. DNS gjør at du kan skrive inn adressen som et ”domain name”, f.eks www.hiof.no, og DNS
					finner da IP adressen til denne, som kan være 158.39.162.29. </p>
					<p>DNS står for Domain Name System. DNS består av et hierarkisk system av navnetjenere. En
					navnetjener inneholder noen opplysninger som er tilknyttet et maskinnavn på Internet. Primært er det
					IP-nummeret som PC’en (brukeren) forespør etter. Hvis den ikke kjenner IP-adressen, videresender
					den forespørselen til en root-navnetjener.</p>
					<p>Hvis det brukes «interaktion» metode, vil root-navnetjeneren sende svar tilbake om hvem som er «toplevel-domain»
					navnetjener, som da blir spurt.</p>
				</div>
				<div class="w5 fr sl">
					<p>Denne gir info tilbake om hvem som er domenets
					autoritative navnetjener, som da blir spurt og som svarer med informasjon om den aktuelle IP-adressen.
					Den lokale navnetjeneren svarer deretter den spørrende maskinen. </p>
					<p>Hvis det brukes «rekursiv» metode, vil root-navnetjeneren sende forespørselen videre til TLD
					navnetjener, som igjen sender forespørselen videre til den autorative navnetjeneren. Svarene går
					samme vei tilbake til den første (spørrende) navnetjeneren. Se figur.</p>
					<p>Den første navnetjeneren, som originalt sendte forespørselen, vil kopiere opplysningen om det
					maskinnavnet, og la den være hos seg i en viss tid (TTL), i tilfelle det blir en ny forespørsel. </p>
					<p>Etter at den tiden er gått ut, vil opplysningene om den maskinen bli slettet.
					DNS kan også benyttes til host aliasing, mail server aliasing og lastdeling mellom flere web-servere. </p>
				</div>


				<h3>Hva slags info ligger i en record i DNS? </h3>
				<p>En DNS record inneholder fire felt: NAME, VALUE, TYPE, TTL. </p>
				<p>TTL angir hvor lenge navneopplysningene skal leve før den blir fjernet ifra cache. </p>
				<p>NAME og VALUE avhenger av TYPE: (Her er en oversikt over de mest brukte TYPE):</p>
				<ul class="nostyle i0">
					<li>
						<p>Dersom <strong>TYPE=A</strong> (Address) så er NAME=hostnavn og VALUE=ip-adressen (IPv4) for
						hostnavnet. Dersom TYPE=AAAA (Address) så er NAME=hostnavn og VALUE=ipadressen
						(IPv6) for hostnavnet. </p>
					</li>
					<li>
						<p>Dersom <strong>TYPE=NS</strong> (Name Server) så er NAME=domain, for eksempel hiof.no, mens VALUE er
						hostnavnet til en autoritativ DNS server som kan å få tak i ipadressene til hosts i det domainet. </p>
					</li>
					<li>
						<p>Dersom <strong>TYPE=CNAME</strong> (Canonical Name) så vil NAME være et alias navn mens VALUE er det
						virkelige hostnavnet. </p>
					</li>
					<li>
						<p>Dersom <strong>TYPE=MX</strong> (Mail eXchange) så vil NAME være et alias navn for mailserver mens
						VALUE er det virkelige hostnavnet til mailserveren. </p>
					</li>
				</ul>
			</div>
		</section>
		<section>
			<div class="row">
				<h3>SMTP har endel svakheter. Gi en kort beskrivelse av (en del av) disse.</h3>
				<p>SMTP (Simple Mail Transfer Protocol) er en gammel protokoll for e-post. Den fungerer mellom mailservere.
				RFC 733 for SMTP er fra 1977, men SMTP eksisterte også før det. Den gang ble e-post kun
				brukt til å sende tekst, som benyttet ASCII-tegnene for bokstaver og tegn. I ASCII-tabellen ligger
				bokstaver, talltegn og andre tegn i den første del av ASCII-tabellen. Dvs at det kun var nødvendig å
				sende 7 bit per tegn. I den første del av ASCII-tabellen er den 8.ende bit’en, DB7 = ’0’. Den biten
				trengte da ikke å bli sendt. </p>
				<p>SMTP er basert på 7 bit dataoverføring. Nå er det jo stort sett bare 8 bit dataoverføring som brukes.
				Disse må nå først gjøres om til 7 bit, før de kan sendes via SMTP. Dette får man til ved å bruke MIME.
				Hadde SMTP vært laget for 8 bit overføring, kunne man i prinsippet sluppet MIME. Det kan man da si
				er en svakhet for SMTP. </p>
				<p>En annen svakhet ved SMTP er at det er relativt enkelt å lage en ”falsk” avsender for e-post. All info
				ligger i klartekst.</p>


				<h3>Nevn de tre mest kjente protokollene som brukes mellom en epost server og en klient.
				Forklar kort om forskjellene på de</h3>
				<h4>POP3</h4>
				<p>Denne protokollen var en av de første som ble brukt. Her ble eposten lastet ned på din PC,
				fra epost serveren. Vanligvis ble eposten slettet fra epost-serveren rett etter at den ble lastet
				ned til din PC. Når du svarte på en epost (reply) så gjorde du det på din PC, som så lastet
				opp denne epost til epost serveren, som så sendte den. – POP3 hadde ikke mulighet til å
				organisere epost på epost-serveren, i f.eks mapper. Det ble også et problem hvis du brukte
				flere forskjellige PC’er til til epost. POP3 var laget for at du kun brukte en PC til din epost
				behandling. For å bruke denne må du ha et program som har mulighet til å bruke POP3,
				som må settes opp med en del parametere, som f.eks epost-serverens adresse.</p>

				<h4>IMAP</h4>
				<p>Denne protokollen tok var laget for at du kunne bruke flere forskjellige PC’er til din epostbehandling.
				Her kunne all epost organiseres på selve epost-serveren, i f.eks mapper. Det lå
				også flere funksjoner inne i denne protokollen. For å bruke denne må du ha et program
				som har mulighet til å bruke IMAP, som må settes opp, tilsvarende POP3</p>

				<h4>HTTP</h4>
				<p>Hvis du bare har en web-browser tilgjengelig på din PC, kan du allikevel behandle din
				epost på epost-serveren. Du trenger ikke sette opp denne først, det er nok å vite
				webadressen. Denne er meget praktisk å bruke hvis du f.eks skal lese og behandle din
				epost på en fremmeds PC, f.eks på en internet kafe ol.</p>


				<h3>Hva er VPN? Forklar litt om det.</h3>
				<p>VPN står for Virtual Private Network. VPN lager en sikker(kryptert) kanal gjennom et usikret
				internet. Du tilknytter deg til en VPN server, som er lokalisert i ditt private nettverk, eller på
				intranettet på f.eks jobben/skolen. Du har også nødvendig programvare på din «host». All din
				kommunikasjon på internet går via denne VPN serveren, slik at det ser ut som om du er innenfor
				dette private nettverket, eller intranett. Du får da også tilgang til tjenester/dokumenter som bare
				tilbys på dette intranettet.</p>


				<h3>Forklar hvordan checksum på transportlaget virker. Angi hva bitverdien i checksum
				feltet blir, hvis du sender 3 stk 16 bit data. Det som sendes er de 8 bit ASCII-verdiene:
				'A8' , '3F' og 'fa'. Ta med hvordan du kom fram til checksummen.</h3>
				
				<div class="clear">
					<div class="w6 fl sr">
						<p>Dataene blir summer på 16 bits nivå. Overskytende mente blir lagt til, og tilslutt blir svaret
						invertert, og lagt i checksumfeltet. Mottageren gjør samme beregning, unntatt den siste
						inverteringen. Når så mottagerens svar blir summer med det som er i checksumfeltet, blir
						svaret 1</p>
						<p>Vi slår opp i ASCII-tabellen og finner ut bitmønstrene for de tre 16 bits ASCII verdiene
						'A8' , '3F' og 'fa'. Vi summer de to første først, og legger til den siste:</p>
					</div>
					<div class="w4 fr sl">
						<table>
							<tbody>
								<tr>
									<td></td>
									<td>A8</td>
									<td>=></td>
									<td>01000001 00111000</td>
								</tr>
								<tr>
									<td>+</td>
									<td>3F</td>
									<td>=></td>
									<td>00110011 01000110</td>
								</tr>
								<tr>
									<td><hr></td>
									<td><hr></td>
									<td><hr></td>
									<td><hr></td>
								</tr>
								<tr>
									<td></td>
									<td></td>
									<td></td>
									<td>01110100 01111110</td>
								</tr>
								<tr>
									<td>+</td>
									<td>FA</td>
									<td>=></td>
									<td>01100110 01100001</td>
								</tr>
								<tr>
									<td><hr></td>
									<td><hr></td>
									<td><hr></td>
									<td><hr></td>
								</tr>
								<tr>
									<td></td>
									<td></td>
									<td></td>
									<td>11011010 11011111</td>
								</tr>
							</tbody>
						</table>
						<p>Invertert => <code>00100101 00100000</code> som legges i checksumfeltet</p>
					</div>
				</div>
			</div>
			<div class="row">
				<h3>Gitt følgende datasignal, som er en jevn strøm av skiftevis 0 og 1:</h3>
				<img class="w8 centered" src="https://i.xdh.no/b92155b9efa0">
				<p>Dette datasignalet skal overføres på en kabel. Hva må vi sette som krav til
				båndbredde for denne kabelen, når: </p>

				<h4>a. Tiden t er 1 µs?</h4>
				<p>Vi vet at et slikt datasignal består av en sum av mange sinus-signaler, med forskjellig
				frekvens. Hvis vi tar bort alle sinus-signalene med høye frekvenser, og bare sitter igjen
				med ett sinus-signal, som er grunnfrekvensen i datasignalet. I figuren under ser du den
				grunnfrekvensen tegnet inn i datasignalet: </p>
				<img class="w8 centered" src="https://i.xdh.no/7b4b41cf8448">
				<p>Ut fra dette sinussignalet er det mulig å gjenskape bitmønsteret som sendes. Vi må sette
				som krav til båndbredden for kabelen at det sinus-signalet kan overføres. Frekvensen på
				dette sinus-signalet er gitt av ”en delt på perioden av signalet”. Perioden er gitt av
				avstanden i tid mellom to punkter på kurven som er like. I figuren over er den tiden 2·t.
				Det gir en frekvens på:</p>
				<div class="katex">
					  1/2 \cdot t
					= 1/2 \cdot 1 \mu s
					= 1/2 \cdot 10^{-6}s
					= 0.5 \cdot 10^6 Hz
					= 500 \cdot 10^3 Hz
					= 500 KHz.
				</div>
				<p>Kravet til båndbredde er altså 500 KHz</p>

				<h4>b. Tiden t er 20 ns ? </h4>
				<p>Kravet til båndbredde her er: </p>
				<div class="katex">
					  1/2 \cdot t
					= 1/2 \cdot 20ns
					= 1/40 \cdot 10^{-9}s
					= 0.025 \cdot 10^9 Hz
					= 25 \cdot 10^6 Hz
					= 25 MHz.
				</div>


				<h3>Lag en tegning av det mottatte signalet, fra oppgave 1a), når det har gått
				igjennom en kabel som akkurat oppfyller kravet til båndbredde</h3>
				<img class="w5 centered" src="https://i.xdh.no/2e5cf4b388dc">
			</div>
		</section>
	</div>
	<div class="wrapper">
		<section>
			<div class="row">
				<h3>Anta at du bruker wireless til dataoverføring. I spesifikasjonen for wirelessnettet
				du skal bruke, står ord som: Center frequency, channel width og
				channel. Forklar hva de ordene betyr.</h3>
				<p>Center frequency er frekvensen (bærebølgen) som brukes til å modulere
				datasignalet. Et modulert datasignal har en viss båndbredde. Den bruker en del
				av frekvensen rundt bærebølgen. Denne delen kalles channel width. En kanal er
				en del av frekvensområdet som brukes til datakommunikasjon. Det
				frekvensområdet er rundt bærebølgen som brukes i den kanalen</p>


				<h3>Anta at du har et WiFi nett. Forklar forskjellene mellom et ad-hoc nett, og et
				nett med infrastruktur.</h3>
				<p>I et ad-hoc nett vil alle host kunne ta initiativ til å sende til en annen host på adhoc
				nettet. I et nett med infrastruktur er det et aksesspunkt (AP) som styrer all
				kommunikasjon. En host kan ikke sende før et AP spør den om den har noe å
				sende. </p>


				<h3>Anta at du har et WiFi nett. Forklar hvordan aksessmetodene virker.</h3>
				<p>I WiFi brukes to forskjellige system når det gjelder aksess. Det er PCF (Point
				Coordination Function) og DCP (Distributed Coordination Function), I PCF er det
				en basestasjon (aksesspunkt=AP) som spør hver enkel host om den har noe å
				sende, altså nett med infrastruktur. Ingen host kan aksessere mediet uten å ha blitt
				spurt av basestasjnen (AP).
				I DCF kan hvilken som helst host i nettet ta initiativ til å sende, altså et ad-hoc
				nett. Da brukes CSMA/CA aksess</p>
				<div class="i1">
					<p>Carrier Sense Multiple Access med Collision Avoidance virker slik: En
					stasjon som ønsker å sende, må først lytte, for å høre om det er noen
					aktivitet på kanalen. Hvis det er aktivitet, må den vente. Så fort aktiviteten
					er over, må den vente ytterligere DIFS tid før den starter sending. Hvis noen
					andre da har begynt å sende, må den fortsette å vente. </p>
					<p>Når pakken er sent, venter den på ACK pakke fra mottager. Hvis den ikke
					kommer innen en viss tid, sender den pakken på nytt. Dette kan gjentas et
					visst antall ganger. </p>
					<p>CSMA/CA kan også bruke RTS og CTS. Stasjonen som skal sende, sender
					da først en RTS pakke, hvor det er info om hvor lang tid sendingen vil pågå.
					Det er for at andre stasjoner ikke skal sende i denne perioden. Den
					mottagende stasjon svarer på RTS med en CTS pakke, med samme info om
					tid på sendingen. De stasjonene som kun hører mottager, vil dermed også
					ikke sende i den perioden. Når sende stasjonen har mottatt CTS, sende den
					datapakka</p>
				</div>
				<p>Nå skal DCF og PCF kunne virke samtidig i et nett. Det løses ved å innføre
				bestemte tidsintervall, med forskjellig lengde.. En pågående kommunikasjon gjør
				seg ferdig. Neste pakke i kommunikasjonen venter den korteste intervalltiden;
				SIFS, før neste pakke sendes. Når kommunikasjonen er ferdig, kan neste begynne
				å kommunisere. Da har PCF fortrinn. PCF kan starte sending etter tiden PIFS,
				som er litt lenger enn SIFS. Når den kommunikasjonen er ferdig, kan neste DCF
				kommunikasjon starte. De må vente DIFS tid, som er litt lenger enn PIFS tiden. </p>
			</div>
			<div class="row">
				<h3>Beskriv virkemåten til CRC, og hvilke styrker / svakheter den har?</h3>
				<p>Cyclic Redundancy Check (CRC) er en feilkontroll som brukes for å oppdage
				bitfeil i datapakker. CRC utfører en beregning av det som er i datapakka. Resultatet
				av denne beregningen legges i gjerne i slutten av datapakka som sendes over, i
				CRC feltet (eller FCS feltet). Mottageren utfører tilsvarende beregning, og vil da
				kunne oppdage bitfeil i datapakka.</p>
				<p>CRC bruker et polynom (G) i sin beregning. Hvis polynomet G består av r+1 bit,
				legges det til r stk 0’ere i slutten av datapakka. Denne utvidede datapakka blir
				«modula 2 dividert» på G. Resten etter denne «divisjonen» blir lagt inn i CRC
				feltet. Når så mottager utfører samme «divisjon», på datapakka som tas imot, vil
				resten bli null, hvis det ikke er bitfeil. </p>
				<p>Styrken er at denne type feilkontroll vil oppdage alle typer feil, unntatt der hvor
				feilmønsteret (E) i den mottatte pakka er lik polynomet. Hvis f.eks G = 1011, så vil
				ikke en pakke som har E=1011 oppdages. Dvs feil i en bit, og neste bit er feilfri og
				to neste bit er feil.</p>
				<p>CRC har få svakheter. CRC er ofte implementert i hardware, og det er da ikke
				mulig å forandre polynomet. Hvis den implementeres i software, vil den kreve en
				del prosessorkraft.</p>


				<h3>Hvor mange bit er det i FCS, når polynomet <span class="katex">G(x)= x^8+x^5+x^4+1</span>?</h3>
				<p>Dette polynomet brukes til å regne ut hva som skal være i FCS i datapakka. Se
				ellers beskrivelsen i oppgave 1.</p>


				<h3>Hva vil det si at en protokoll bruker polynomet <span class="katex">G(x)= x^8+x^5+x^4+1</span>?</h3>
				<p>Antall bit i FCS bestemmes av den høyeste potensen i polynoment. Her er det 8, dvs det er 8 bit FCS</p>


				<h3>Beskriv kort de forskjellige typer fiber. Ta med oppbyggingen, lysgangen og
				(de mest sentrale) spesifikasjonene.</h3>
				<p>Det finnes to hovedtyper fiber kabel: Multimodus (MM) og Singlemodus (SM). MM
				fiber finnes også i to typer, det er Gradert indeks (GI) og Step indeks (SI) fiber. Du finner
				ofte ikke info i databladet om MM-fiberen er SI eller GI. Det er fordi det (nesten) bare
				produseres GI fiber, av disse MM fibrene. GI fiber har nemlig mye større båndbredde enn
				en SI fiber. Det er fordi dispersjonen er litt mindre i en GI fiber i forhold til en SI fiber</p>
				<p>Størrelsen på kjernediameteren, altså kjernen i fiberkabelen, der lyset går, bestemmer om
				det er en SM fiber eller MM fiber. Kjernediameteren må være liten, i størrelsesorden
				9 µm, for at den skal kunne være SM. I en SM fiber er det bare plass til en lysstråle, noe
				som medfører at det ikke er modedispersjon i en SM fiber. Det er kun kromatisk
				dispersjon, som i hovedsak skyldes at brytningsindeksen er litt forskjellig for de
				forskjellige bølgelengdene på lyset. Lyshastigheten er gitt av brytningsindeksen, og da vil
				lyshastigheten være litt forskjellig for de forskjellige bølgelengdene.</p>
				<p>I en MM fiber er det dispersjon pga de forskjellige lysstrålene går forskjellig
				veistrekning. Det kalles modedispersjon. De som går lengst vei, kommer senest fram. I en
				GI fiber er lyshastigheten på de lysstrålene som går lengst vei litt større, som medfører at
				dispersjonen er litt mindre enn i en SI fiber, hvor lyshastigheten er lik for alle lysstrålene.</p>
				<p>En fiberkabel har også en Numerisk Aperture (NA), som er sinus til den største vinkelen
				lyset inn på kjernen kan ha, for at lyset skal kunne sendes videre i kjernen. Dvs at det blir
				totalrefleksjon mellom kjerne og kappe.</p>


				<h3>Hva er båndbredden på en fiberoptisk forbindelse på 5 km, når
				båndbredden på fiberen er 10 [MHz·km] ?</h3>
				<p>Båndbredden B på en 5 km fiberforbindelsen, ved bruk av en fiber med 10
				MHz*km, er:
				B = 10/5 MHz = 2 MHz</p>
			</div>
			<div class="row">
				<h3>Bør du velge en fiber med høy eller lav NA, hvis du ønsker å få mest mulig lys
				inn i fiberen, altså ha minst mulig innkoblingstap. Forklar hvorfor.</h3>
				<p>Man bør velge en fiber med høyest mulig NA hvis man ønsker minst mulig innkoblingstap
				i fiberen. NA er definert som sinus til den største vinkelen en lysstråle kan ha inn på
				fiberen, for å bli ført videre i kjernen. Jo større NA, jo større vinkel.</p>
				<p>Hvis man bruker en LED som lyskilde, stråler den ut lys i alle retninger. Hvor mye av dette
				som faktisk blir koblet inn i fiberen, er avhengig av (bl.a.) NA. Ved bruk av fiber med høy
				NA vil også de lysstålene med stor vinkel bli koblet inn i fiberen. Med bruk av lav NA ville
				disse lysstrålene bli tapt. Dette regnes da med i innkoblingstapet, slik at innkoblingstapet
				blir da større.</p>
			</div>
		</section>
		<section>
			<div class="row">
				<h3>Bør du velge en fiber med høy eller lav NA, hvis du ønsker å ha høyest
				båndbredde på fiberen. Forklar hvorfor.</h3>
				<p>Man bør velge en fiber med lavest mulig NA, hvis man ønsker fiber med høyest mulig
				båndbredde.
				Båndbredden på en multimodus fiber er gitt av modedispersjonen. Modedispersjonen
				skyldes at de forskjellige lysstrålene (modene) går forskjellig vei (og lengde) i fiberen, og
				kommer dermed fram til forskjellige tidspunkt. Maksimal forskjell i lengde er det mellom
				den strålen som går rett fram, og den som har maksimal vinkel i forhold til retningen fram i
				fiberen. Den prosentvise forskjellen i lengde er større i en fiber med høy NA, enn en med
				lav NA. Jo større prosentvis forskjell det er i lengde, desto større tidsforskjell, dvs større
				modedispersjon, som igjen gir mindre båndbredde.</p>


				<h3>NHva blir båndbredden på en fiberoptisk forbindelse, når den totale
				dispersjonen er på 10 [ns] ?</h3>
				<p>Forholdet mellom dispersjon <span class="katex">\tau</span>, og båndbredde B er gitt av formelen:</p>
				<p>B = 0,44/<span class="katex">\tau</span></p>
				<p>Ved en dispersjon på <span class="katex">10[ns] (= 10 \cdot 10^{-9}[s] = 10^{-8}[s]</span>, får vi en båndbredde på:</p>
				<p class="katex">B=0,44/10^{-8} = 0,44 \cdot 10^8 Hz = 44 MHz</p>


				<h3>Hva er båndbredden på en fiberoptisk forbindelse på 5 km, når båndbredden
				på fiberen er 10 [MHz·km] ?</h3>
				<p>Båndbredden B på en 5 km fiberforbindelsen, ved bruk av en fiber med 10 MHz*km, er:
				B = 10/5 MHz = 2 MHz</p>


				<h3>Forklar hva modedispersjon er.</h3>
				<p>Se forklaring i løsningen til oppgave nr.2</p>


				<h3>Du har en fiberoptisk forbindelse som er 35 km lang. Der brukes det en
				singlemode fiber (SM) med en dispersjon på 5 [ps/(nm·km)], og en laser med
				en spektral båndbredde på 2 [nm]. Hva blir båndbredden på den
				forbindelsen?</h3>
				<p>Båndbredden er gitt av den kromatiske dispersjonen i SM-fiberen, lengden på fiberen og
				den spektrale båndbredde på lyskilden:</p>
				<p class="katex">B = 0,44/\tau = 0,44/ (35 \cdot 2 \cdot 5)ps = 0,44/0,35 ns = 1,26 GHz</p>


				<h3>Du har et fiberoptisk anlegg der senderen har en innkoblet effekt på -10,0 dBm,
				mottageren har en følsomhet på -37,0 dBm, fiberen har en dempning på 2,5
				dB/km, lengden er på 2,0 km hvor det er to skjøter med en dempning på 0,1 dB
				(hver), og det er to kontakter med en dempning på 1,0 dB (hver). Kontaktene
				er montert på selve fiberkabelen. Hva blir systemmarginen?</h3>
				<p>Systemmarginen kan man finne ved å sette opp effektbudsjettet.</p>
				<div class="katex">
					P_i - P_{fiber} - P_{sk} - P_{kon} - P_{sy}
					= P_m - 10 - 5 - 0,2 - 2 - P_{sy}
					= -37
				</div>
				<div class="katex">
					P_{sy} = 37 - 17,2 = 19,8 [dB]
				</div>


				<p>Du skal dimensjonere et fiberoptisk anlegg. Du skal bruke en 50/125 µm
				fiberkabel, med en båndbredde på 50MHz*km. Dempningen i 1.vindu er på 3,0
				dB/km. Fiberkabelen leveres i lengder på 1,0 km. Dvs. for hver kilometer må
				kabelen skjøtes. Skjøtetapet er på 0,2 dB.- En kort fiberstump er limt inn ved
				henholdsvis senderen og mottageren. Fra senderen og mottageren går det en
				kort fiberstump til en kontakt. Du må bruke en kontakt i hver ende.
				Kontaktapet er på 1,0 dB. Disse kontaktene kan bli "møkkete". - Kravet er at
				anlegget skal kunne akseptere et tap på opp til 3,0 dB per kontakt.
				Systemarginen bør være på 5 dB.</p>

				<h4>a) Hvilken følsomhet må mottageren ha, når senderen har en innkoblet effekt på
				-18 dBm, og fiberkabelen er 10 km lang ?</h4>
				<p>Hvilken følsomhet mottageren må ha kan finnes ved å sette opp effektbudsjettet.
				I oppsettet er det ikke gitt noe data for innkoblingstapet ved mottageren. Den kan
				settes til 1,0 dB.
				Vi får da:</p>
				<div class="katex">
					P_i - P_{fi} - P_{sk} - P_{nnk.m} - P_{sy}
					= P_m - 18 - 30 - 1,8 - 6 - 1 - 5
					= P_m
				</div>
				<div class="katex">
					P_m = - 61,8 [dBm]
				</div>
				<p>Mottageren må ha en følsomhet på bedre enn –61,8 dBm.</p>

				<h4>b) Hvis du har en sender på -18 dBm og en mottager med følsomhet på -50,0
				dBm, - hvor lang fiberkabel kan du da ha ?</h4>
				<p>Hvis følsomheten til mottageren hadde vært på –50,0 dBm kunne vi hatt en fiberkabel
				på maks X km:</p>
				<div class="katex">
					P_i - P_{fi} - P_{sk} - P_{kon} - P_{nnk.m} - P_{sy}
					= P_m - 18 - 30 X - 0,2 X - 6 - 1 - 5
					= -50
				</div>
				<div class="katex inline">
					X \cdot 3,2 = 50 - 18 -12 = 20
				</div>
				<div class="katex inline i5">
					X = 20 / 3,2 = 6,25
				</div>
				<p>Ved en lengde på 6,25 km får vi</p>
				<div class="katex">
					P_i - P_{fi} - P_{sk} - P_{kon} - P_{nnk.m} - P_{sy}
					= P_m - 18 - 6,25 \cdot 30 - 6 \cdot 0,2 - 6 - 1 - P_{sy}
				</div>
				<div class="katex inline">
					= -50
				</div>
				<div class="katex inline i5">
					P_{sy} = 50 - 18 - 18,75 - 1,2 - 7
					           = 5,05 [dB]\ i\ systemmargin
				</div>
				<p>Lengden på fiberkabelen kan være 6,25 km</p>

				<h4>c) Hva er maksimal datahastighet på datasignalet i de to tilfellene ?</h4>
				<p>Da ikke annet er oppgitt er maksimal datahastighet lik det dobbelte av båndbredden.
				Vi tar utgangspunkt i fiberkabelens data på 50 MHz*km :</p>
				<p>Da fiberkabelen er 10Km blir maks datahastighet D, lik:
				D = 2*B = (2*50 / 10) Mbit/s = 10 Mbit/s</p>
				<p>Da fiberkabelen er 6,25Km blir maks datahastighet D, lik:
				D = 2*B = (2*50 / 6,25) Mbit/s = 16 Mbit/s</p>
			</div>
			<div class="row">
				<h1>Ord og utrykk</h1>
				<dl>
					<dt>Frame</dt>
					<dd>Referer til en datapakke på lag 2 i TCP/IP stack'en. En "frame" er en datapakke som er klar til å sendes til neste punkt i et nettverk.</dd>
					
					<dt>FCS</dt>
					<dd>Frame Check Sequence: felt som brukes til error-detection.</dd>
					
					<dt>Ethertype</dt>
					<dd>Brukes til å indikere hvilken protokoll som er innkapslet i payload til framen. Feltet brukes
					også til å angi størrelsen på noen Ethernet-frame</dd>
					
					<dt>IEEE 802.1Q tag</dt>
					<dd>Et felt som hvis tilstede, indikerer det VLAN medlemskap og IEEE 802.1p prioritet.</dd>

					<dt>VLAN</dt>
					<dd>VLANVLANVLANVLANVLANVLANVLAN</dd>

					<dt>Gateway</dt>
					<dd>GatewayGatewayGatewayGatewayGatewayGatewayGateway</dd>

					<dt>Nettmaske</dt>
					<dd>NettmaskeNettmaskeNettmaskeNettmaskeNettmaskeNettmaskeNettmaske</dd>

					<dt>Switch</dt>
					<dd>SwitchSwitchSwitchSwitchSwitchSwitchSwitch</dd>

					<dt>Ruter</dt>
					<dd>RuterRuterRuterRuterRuterRuterRuter</dd>

				</dl>
			</div>
		</section>
		<section>
			<div class="row">
				<h1>Ting & tang</h1>
				<dl>
					<dt>Ethernet frame & header</dt>
					<dt>Frame</dt>
					
					<dd>En datapakke på en Ethernet-link kalles en Ethernet-pakke, som transporterer en Ethernet-frame
					som payload. Hver frame starter med en Ethernet-header, midt delen inneholder payload data og inkluderer
					eventuelle header for protokoller (eks: IP header). Framen slutter med en (FCS)</dd>
					<dt>Header</dt>
					<dd>Inneholder to MAC adresser (src, dest), EtherType feltet og et IEEE 802.1Q tag (valgfritt)</dd>
					
					<dt>ARP</dt>
					<dd>ARP kartlegger (dynamisk) hvilken IP adresse (Lag 3 adressen) hver MAC adresse (Lag 2 adressen)
					har, på et nett. En host, som skal sende data, trenger MAC adressen til (første/neste) mottager på
					veien til slutt mottager. En host lagrer oversikten over MAC-IP som fås via ARP, i sitt cache minne, for
					en kort stund. ARP er en request og reply protokoll. ARP kan bare brukes til å finne MAC adressen til en IP
					adresse innenfor et nett. ARP virker på lag 2. ARP brukes også bare på IPv4, for di IPv6 bruker Neighbor
					Discovery Protocol, som er en del av ICMPv6.</dd>

					<dt>HTTP</dt>
					<dd>HTTP er laget for kommunikasjon mellom en webserver og webklient (web browser), hvor mange forskjellige 
					filtyper kan overføres. HTTP virker som en request-response protokoll mellom webklienten og webserveren. 
					Webklienten sender en request pakke og webserveren svarer med en response pakke. Respons pakken inneholder status 
					informasjon og kan også inneholde informasjonen request pakken spurte etter.
					</dd>
					<dd>
						I HTTP requestet kan vi se at metoden GET brukes. HTTP versjonen er 1.1. 
						Andre ting i request headeren er User-Agent (info om client), 
						hva man skal akseptere som respons, samt info om respons kan være komprimert eller ikke.
					</dd>
					<dd>
						I HTTP responsen vil man få status kode og tekst, her ser vi at status kode er 200 og tekst er OK. 
						Responsen inneholder også hvilken web-server som er i bruk (Apache), serveren sin dato, når siden ble sist endret, samt hvor langt innholdet er. 
						I Line-based text data: text/html ser vi selve innholdet som blir sendt.
					</dd>

					<dt>IPv6 shorthand notation</dt>
					<dd>Flere seksjoner med bare 0-ere kan gjøres om til <code>::</code> (brukes kun en gang, der hvor
					den fjerner mest 0-ere)</dd>
					<dd>Ledene 0-ere før andre tall kan også fjernes.</dd>
					<dd>Hvis det er flere 0-er seksjoner indikeres det med <code>:0:</code> (en per seksjon)</dd>
					<dd>Eks: <code>2607:F6D0:0000:005A:0000:0000:0000:07C0</code> blir <code>2607:F6D0:0:5A::7C0</code></dd>

					<dt>Unicast</dt>
					
					<dt>Anycast</dt>
					<dd>Er støttet kun i IPv6 og ikke IPv4 (men IPv4 har en workaround)</dd>
					<dd>Anycast er en nettverksadressering og rutemetode. En pakke med en anycast adresse blir sendt til en
					destinasjon. Destinasjons velges ut fra om den er nærmest, lavest kostnad, sunnest, minst overbelastet
					eller en annen type avstands måling. Anycast adresse kan brukes der det er (for) mye trafikk til et
					nettsted, slik at datatrafikken må deles over flere maskiner. Der hvor en maskin ikke vil klare å
					behandle all trafikk.</dd>

					<dt>IPV4 anycast workaround</dt>
					<dd>Kan i mange tilfeller gjøres vha. BGP. Flere verter (vanligvis i forskjellige
					geografiske områder) får samme unicast IP-adresse, og forskjellige ruter til adressen blir annonsert
					gjennom BGP. Rutere anser disse for å være alternative ruter til samme destinasjon, selv om de
					faktisk er ruter til forskjellige destinasjoner med samme adresse. Som vanlig velger rutere en rute
					basert på hvilken avstandsmål som er i bruk (minst kostnad, minst overbelastet, kortest). Å velge en
					rute i dette oppsettet, vil være det samme som å velge en destinasjon.</dd>
					
					<dt>Multicast</dt>
					<dt>Broadcast</dt>
					<dt>NAT</dt>

					<dt>Netmask kalkulasjon</dt>
					<dd>Man teller antall 1-ere i binærformen...<br></dd>
					<dd><code>255.255.255.255</code> = <code>11111111.11111111.11111111.11111111</code> = <code>/32</code><br></dd>
					<dd><code>255.255.255.128</code> = <code>11111111.11111111.11111111.10000000</code> = <code>/25</code></dd>
				</dl>
			</div>
			<div class="row bt bl">

			</div>
		</section>
	</div>
</body>
</html>